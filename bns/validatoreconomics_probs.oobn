class validatoreconomics_probs
{
    inputs = (EB);
    outputs = (Candidate EB_copy);
    node_size = (80 40);
    HR_Instantiated_in = "\"validatoreconomics\"";
    HR_TextLabel_1_BackgroundColor = "#ffffff";
    HR_TextLabel_1_TextColor = "#333333";
    HR_TextLabel_1_Font = "Dialog-PLAIN-13";
    HR_TextLabel_1_Size = "100,50";
    HR_TextLabel_1_Position = "17,628";
    HR_TextLabel_1_Description = "Version 4";
    HR_DBN_Use_BK = "0";
    HR_Html_Desc = "0";
    HR_HTML_Desc = "This model is a simple HMM<br><br>it models development of temperature over time.<br><br>One time step is one year<br><br>Each year we observe the number of tree rings.<br><br>A Revealing Introduction to Hidden Markov Models<br>Mark Stamp\3<br>Associate Professor<br>Department of Computer Science<br>San Jose State University<br>September 28, 2012<br>1 A simple example<br>Suppose we want to determine the average annual temperature at a particular location on<br>earth over a series of years. To make it interesting, suppose the years we are concerned with<br>lie in the distant past, before thermometers were invented.<br><br>To simplify the problem, we only consider two annual temperatures, \\hot\" and \\cold\".<br>Suppose that modern evidence indicates that the probability of a hot year followed by another<br>hot year is 0.7 and the probability that a cold year is followed by another cold year is 0.6.<br>We'll assume that these probabilities held in the distant past as well<br><br>Also suppose that current research indicates a correlation between the size of tree growth<br>rings and temperature.";
    HR_Link_Groups_IDs = "";
    HR_Node_Label_Style = "0";
    HR_Group_3_Color = "25";
    HR_Group_3_Name = "BN_Info";
    HR_Groups_IDs = "3";
    HR_TextLabel_IDs = "";
    HR_CPT_Font_Size = "-12";
    HR_CPT_Font_Name = "com.apple.laf.AquaFonts$DerivedUIResourceFont[family=Lucida Grande,name=Lucida Grande,style=plain,size=13]";
    HR_CPT_Font_Italic = "0";
    HR_CPT_Font_Weight = "400";
    HR_Monitor_Variance_Utility = "1";
    HR_Monitor_Display_Prob_DD = "0";
    HR_DBN_Num_Slices = "5";
    HR_Desc = "This model is a simple HMM\n\nit models development of temperature over time.\n\nOne time step is one year\n\nEach year we observe the number of tree rings.\n\nA Revealing Introduction to Hidden Markov Models\nMark Stamp\3\nAssociate Professor\nDepartment of Computer Science\nSan Jose State University\nSeptember 28, 2012\n1 A simple example\nSuppose we want to determine the average annual temperature at a particular location on\nearth over a series of years. To make it interesting, suppose the years we are concerned with\nlie in the distant past, before thermometers were invented.\n\nTo simplify the problem, we only consider two annual temperatures, \\hot\" and \\cold\".\nSuppose that modern evidence indicates that the probability of a hot year followed by another\nhot year is 0.7 and the probability that a cold year is followed by another cold year is 0.6.\nWe'll assume that these probabilities held in the distant past as well\n\nAlso suppose that current research indicates a correlation between the size of tree growth\nrings and temperature.";
    HR_OOBN_CheckConsistency = "1";
    HR_OOBN_FitExpand = "1";
    HR_Zoom_ZoomFactor = "111";
    HR_Groups_GroupColors = "";
    HR_Groups_GroupNames = "";
    HR_Groups_UserGroupsNo = "0";
    HR_Utility_Link = "63";
    HR_Probabilistic_Link = "63";
    HR_Functional_Link = "63";
    HR_Binding_Link = "63";
    HR_Information_Arc = "63";
    HR_Color_Interface = "21";
    HR_Color_Instance = "0";
    HR_Color_DiscreteFunction = "5";
    HR_Color_Function = "4";
    HR_Color_Utility = "36";
    HR_Color_Decision = "17";
    HR_Color_ContinuousChance = "48";
    HR_Color_DiscreteChance = "16";
    HR_Monitor_InitSD = "2";
    HR_Monitor_Utility_Arrange = "0";
    HR_Monitor_Mean_Variance = "1";
    HR_Monitor_Chance_Utility = "1";
    HR_Monitor_InitStates = "5";
    HR_Monitor_OpenGraph = "0";
    HR_Monitor_GraphPrecision = "100";
    HR_Monitor_AutoUpdGraph = "0";
    HR_Compile_MaxMinimalSeparators = "100000";
    HR_Compile_ApproxEpsilon = "1.0E-5";
    HR_Compile_Approximate = "0";
    HR_Compile_SaveToMemory = "0";
    HR_Compile_Compress = "0";
    HR_Compile_TriangMethod = "0";
    HR_Propagate_AutoNormal = "1";
    HR_Propagate_AutoSum = "1";
    HR_Propagate_Auto = "1";
    HR_Font_Italic = "0";
    HR_Font_Weight = "400";
    HR_Font_Size = "-12";
    HR_Font_Name = "javax.swing.plaf.FontUIResource[family=Tahoma,name=Tahoma,style=plain,size=11]";
    HR_Grid_GridShow = "0";
    HR_Grid_GridSnap = "1";
    HR_Grid_Y = "40";
    HR_Grid_X = "40";

    function n
    {
	label = "";
	position = (120 200);
	HR_LinkControlPoints = "";
	HR_LinkGroup = "[p_0:0][p_1:0][p_2:0][p_3:0][p_4:0][p_5:0]";
	HR_LinkMode = "[p_0:0][p_1:0][p_2:0][p_3:0][p_4:0][p_5:0]";
	HR_NodeSize = "(80, 40)";
	HR_Group = "0";
	HR_HTML_Desc = "";
	HR_Desc = "";
    }

    function p_5
    {
	label = "";
	position = (640 240);
	HR_LinkGroup = "[Candidate:0]";
	HR_LinkMode = "[Candidate:0]";
	HR_NodeSize = "(80, 40)";
	HR_HTML_Desc = "";
	HR_Desc = "";
	HR_Group = "0";
    }

    function p_4
    {
	label = "";
	position = (560 240);
	HR_LinkGroup = "[Candidate:0]";
	HR_LinkMode = "[Candidate:0]";
	HR_NodeSize = "(80, 40)";
	HR_HTML_Desc = "";
	HR_Desc = "";
	HR_Group = "0";
    }

    function p_3
    {
	label = "";
	position = (480 240);
	HR_LinkGroup = "[Candidate:0]";
	HR_LinkMode = "[Candidate:0]";
	HR_NodeSize = "(80, 40)";
	HR_HTML_Desc = "";
	HR_Desc = "";
	HR_Group = "0";
    }

    function p_2
    {
	label = "";
	position = (400 240);
	HR_LinkGroup = "[Candidate:0]";
	HR_LinkMode = "[Candidate:0]";
	HR_NodeSize = "(80, 40)";
	HR_HTML_Desc = "";
	HR_Desc = "";
	HR_Group = "0";
    }

    function p_1
    {
	label = "";
	position = (320 240);
	HR_LinkGroup = "[Candidate:0]";
	HR_LinkMode = "[Candidate:0]";
	HR_NodeSize = "(80, 40)";
	HR_HTML_Desc = "";
	HR_Desc = "";
	HR_Group = "0";
    }

    function p_0
    {
	label = "";
	position = (236 243);
	HR_LinkMode = "[Candidate:0]";
	HR_LinkGroup = "[Candidate:0]";
	HR_Desc = "";
	HR_HTML_Desc = "";
	HR_NodeSize = "(80, 40)";
	HR_Group = "0";
    }

    discrete function EB_copy
    {
	label = "";
	position = (760 240);
	states = ("0" "1" "2" "3" "4" "5");
	subtype = number;
	state_values = (0 1 2 3 4 5);
	HR_NodeSize = "(80, 40)";
	HR_Group = "0";
	HR_HTML_Desc = "";
	HR_Desc = "";
	HR_State_5 = "";
	HR_State_4 = "";
	HR_State_3 = "";
	HR_State_2 = "";
	HR_State_1 = "";
	HR_State_0 = "";
	HR_LinkControlPoints = "";
	HR_LinkGroup = "[Candidate:0]";
	HR_LinkMode = "[Candidate:0]";
    }

    node Candidate_1
    {
	label = "Validator type \nselected as candidate for\nproposer duty (1)";
	position = (640 80);
	states = ("false" "true");
	subtype = boolean;
	HR_State_0 = "";
	HR_State_1 = "";
	HR_Desc = "";
	HR_NodeSize = "(160, 50)";
	HR_LinkMode = "";
	HR_LinkGroup = "";
	HR_HTML_Desc = "";
	HR_LinkControlPoints = "";
	HR_Group = "0";
    }

    function FAdjTotal
    {
	label = "";
	position = (120 160);
	HR_LinkControlPoints = "";
	HR_LinkGroup = "[p_0:0][p_1:0][p_2:0][p_3:0][p_4:0][p_5:0]";
	HR_LinkMode = "[p_0:0][p_1:0][p_2:0][p_3:0][p_4:0][p_5:0]";
	HR_NodeSize = "(80, 40)";
	HR_Group = "0";
	HR_HTML_Desc = "";
	HR_Desc = "";
    }

    node Candidate
    {
	label = "Validator type \nselected as candidate for\nproposer duty";
	position = (480 400);
	states = ("false" "true");
	subtype = boolean;
	HR_LinkControlPoints = "";
	HR_HTML_Desc = "";
	HR_LinkGroup = "";
	HR_LinkMode = "";
	HR_NodeSize = "(160, 50)";
	HR_Group = "0";
	HR_Desc = "";
	HR_State_1 = "";
	HR_State_0 = "";
    }

    node EB
    {
	label = "Consolidated \nvalidator types";
	position = (446 140);
	states = ("0" "1" "2" "3" "4" "5");
	subtype = number;
	state_values = (1 2 5 10 30 64);
	HR_HTML_Desc = "This node contains the various effective balances, depending on the number of merged validators.";
	HR_State_0 = "";
	HR_State_1 = "";
	HR_Desc = "This node contains the various effective balances, depending on the number of merged validators.";
	HR_NodeSize = "(160, 60)";
	HR_LinkMode = "[Candidate_1:0][ProposerCheck:0][F1:0][DF1:0][FAdjTotal:0][p0:0][p0_1:0][p0_2:0][p0_3:0][p0_4:0][p0_5:0][p_5:0][p_4:0][p_3:0][p_2:0][p_1:0][p_0:0][EB_copy:0]";
	HR_LinkGroup = "[ProposerCheck:0][EB_copy:0][Candidate_1:0][FAdjTotal:0][p_0:0][p_1:0][p_2:0][p_3:0][p_4:0][p_5:0]";
	HR_State_2 = "";
	HR_State_3 = "";
	HR_State_4 = "";
	HR_State_5 = "";
	HR_State_6 = "";
	HR_State_7 = "";
	HR_State_8 = "";
	HR_State_9 = "";
	HR_LinkControlPoints = "";
	HR_Group = "0";
    }

    potential (n)
    {
	model_nodes = ();
	model_data = ( 716800 );
    }

    potential (p_5 | EB FAdjTotal n)
    {
	model_nodes = ();
	model_data = ( probability (#EB == 5) * n / 64 / FAdjTotal );
    }

    potential (p_4 | EB FAdjTotal n)
    {
	model_nodes = ();
	model_data = ( probability (#EB == 4) * n / 30 / FAdjTotal );
    }

    potential (p_3 | EB FAdjTotal n)
    {
	model_nodes = ();
	model_data = ( probability (#EB == 3) * n / 10 / FAdjTotal );
    }

    potential (p_2 | EB FAdjTotal n)
    {
	model_nodes = ();
	model_data = ( probability (#EB == 2) * n / 5 / FAdjTotal );
    }

    potential (p_1 | EB FAdjTotal n)
    {
	model_nodes = ();
	model_data = ( probability (#EB == 1) * n / 2 / FAdjTotal );
    }

    potential (p_0 | EB FAdjTotal n)
    {
	model_nodes = ();
	model_data = ( probability (#EB == 0) * n / 1 / FAdjTotal );
    }

    potential (EB_copy | EB)
    {
	model_nodes = ();
	model_data = ( Distribution (probability (#EB == 0), probability (#EB == 1), probability (#EB == 2), probability (#EB == 3), probability (#EB == 4), probability (#EB == 5)) );
    }

    potential (Candidate_1 | EB)
    {
	data = (( 0.3752 0.6248 )	%  EB=0
		( 0.7202 0.2798 )	%  EB=1
		( 0.9348 0.0652 )	%  EB=2
		( 0.9804 0.0196 )	%  EB=3
		( 0.9938 0.0062 )	%  EB=4
		( 0.9956 0.0044 ));	%  EB=5
    }

    potential (FAdjTotal | EB)
    {
	model_nodes = ();
	model_data = ( 716800 / 1 * probability (#EB == 0) + 716800 / 2 * probability (#EB == 1) + 716800 / 5 * probability (#EB == 2) + 716800 / 10 * probability (#EB == 3) + 716800 / 30 * probability (#EB == 4) + 716800 / 64 * probability (#EB == 5) );
    }

    potential (Candidate | EB_copy p_0 p_1 p_2 p_3 p_4 p_5)
    {
	model_nodes = (EB_copy);
	model_data  = ( Distribution (1 - p_0, p_0),
			Distribution (1 - p_1, p_1),
			Distribution (1 - p_2, p_2),
			Distribution (1 - p_3, p_3),
			Distribution (1 - p_4, p_4),
			Distribution (1 - p_5, p_5) );
    }

    potential (EB)
    {
	data = ( 1 1 1 1 1 1 );
    }
} % class validatoreconomics_probs
