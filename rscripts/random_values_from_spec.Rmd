---
title: "Validator Economics: Proposer selection - random bytes"
author:
- name: Sandra Johnson
  url: https://twitter.com/sandJohnson
  affiliation: Consensys Software Inc (Research Group)
date: "`r Sys.Date()`"
description: 
  Visualisation of the random bytes generated by the spec for validators.
editor_options: 
  markdown: 
    wrap: 72
---

```{r message=FALSE}
#library(data.table)
library(ggplot2)
library(knitr)
library(lubridate)
library(rmarkdown)
library(skimr)
library(tidyverse)

options(digits=10)
options(scipen = 999) 

# See knit options in https://www.r-bloggers.com/2021/03/default-knitr-options-and-hooks/ 
knitr::opts_chunk$set(dpi = if (knitr::is_latex_output()) 72 else 300,
                      echo=FALSE)
```

## Blog post - graph of 716,800 randomly drawn values from U(0,255)
- After the values have been drawn, we need to ensure that they are all *integer values*. We cannot have values greater than 255, so we use the floor function to round down to the nearest integer value.
```{r cache=TRUE}
set.seed(1)

random_byte_values <- runif(716800,0,255)
## ----------------------------------------------
r_int <- floor(random_byte_values)
x <- seq(0,255,1)
r <- data.frame(r_int)

df <- r %>%
  group_by(r_int) %>%
  summarise(y = n()) %>%
  arrange(r_int)

df <- df %>%
  mutate(prob = y/sum(y))

# Plot the proportion of validators receiving particular random bytes (integers)
# Note that there is a small range of values. When we specify ylim(0,0.005) we get a better idea of how close these values are, i.e. all scattered around 0.004.
# ------------------------------------------------------------------------------------------------------
ggplot(data=df, aes(x=r_int,y=prob))  +
  xlab("random_byte values generated from U(0,255)") +
  ylab("proportion of validator set") +
  #ylim(0,0.005) +
  geom_point()  
ggsave("/Users/sandra/data/validator-economics/plots/random-values-generated.png") 

```
```{r}
# Plot the random integers generated by the spec & overlay a uniform distribution
# -------------------------------------------------------------------------------
transparentlightblue <- rgb(173,216,230,max = 255, alpha = 80) # using transparent colour for uniform dist

ggplot(r, aes(x=r_int)) + geom_histogram(bins = 255, aes(y=..density..)) +
   stat_function(fun = dunif, args = list(min = 0, max = 255), geom = "area", 
                  fill = transparentlightblue) + 
    stat_function(fun = dunif, args = list(min = 0, max = 255)) +
  xlab("random bytes generated in 'compute_proposer_index'") +
  ylab("proportion of validators")

ggsave("/Users/sandra/data/validator-economics/plots/random-integers-and-uniform.png")

```



# Blog post - Q-Q plot of random byte values
```{r}
ggplot() +
  geom_qq(data=r, aes(sample=r_int), colour = "turquoise", distribution=qunif) +
  geom_abline(slope=255,intercept=0) +
  coord_flip()

ggsave(ggsave("/Users/sandra/data/validator-economics/plots/random-integers-QQ.png"))

```

## Scenario 2: All the validators have consolidated to the new increased maximum effective balance

-   Using total deposit size as before, i.e. equivalent to 716,800
    validators, will now have an active validator set size of 11,200
-   Generate random bytes to simulate a possible outcome of random bytes
    assigned to each validator.
-   The probability of being chosen based on the effective balance will
    again be 100%, so really this scenario is not of interest, just
    interesting to see how small it got.

## Scenario 3: The active validator set comprises of a "mixed bag" of validators: single stakers, partially consolidated and fully consolidated

Based on the 716,800 active validator set:
- 30% fully consolidated (64-fold) - 3,360 validators with 2048 ETH.   (A)
- 10% partially consolidated (10-fold) - 7,168 validators with 320 ETH (B)
- 10% partially consolidated (5-fold) - 14,336 validators with 156 ETH (C)
- 20% partially consolidated (2-fold) - 71,680 validators with 64 ETH. (D)
- 30% single stake (1-fold) - 215,040 validators with 32 ETH           (E)
Therefore active validator set size = 311,584    

First shuffle the validator types & then generate random bytes for each validator before running through the check for acceptance.



```{r}
set.seed(5394)

random_byte_values <- runif(311584,0,255)

# Scenario 3: Mixture of validators
# -------------------------------------------
validator_idx <- seq(0,311583)
proposer_types <-c(rep(c("A"), times=3360),
                   rep(c("B"), times=7168),
                   rep(c("C"), times=14336),
                   rep(c("D"), times=71680),
                   rep(c("E"), times=215040))

proposers_scenario_3_DF_ordered <- data.table(validator_idx, random_byte_values, proposer_types)
proposers_scenario_3_DF_shuffled <- proposers_scenario_3_DF_ordered %>%
  mutate(shuffled_proposer_types = sample(proposer_types)) %>%
  mutate(selected = case_when(
      (shuffled_proposer_types == "A") & (random_byte_values <= (255*2048)/2048) ~ "yes",
      (shuffled_proposer_types == "B") & (random_byte_values <= (255*320)/2048) ~ "yes",
      (shuffled_proposer_types == "C") & (random_byte_values <= (255*156)/2048) ~ "yes",
      (shuffled_proposer_types == "D") & (random_byte_values <= (255*64)/2048) ~ "yes",
      (shuffled_proposer_types == "E") & (random_byte_values <= (255*32)/2048) ~ "yes",
      TRUE ~ "no")
    )

scenario_3_count <- proposers_scenario_3_DF_shuffled %>% 
  group_by(shuffled_proposer_types) %>%
  count(selected)

scenario3_barchart <- ggplot(data=scenario_3_count) + 
#  geom_col(aes(x=shuffled_proposer_types,y=n, fill=selected)) +
  geom_col(aes(x=shuffled_proposer_types,y=n,  fill=selected), position = "dodge") +
  xlab("Was candidate index selected as proposer?") +
  ylab("Number of validators") 

ggsave("/Users/sandra/data/rig/plots/scenario3_barchart.png")

# Check if there is another way of showing the relative yes to no selections...
# scenario3_barchart2 <- ggplot(data=scenario_3_count) + 
#   geom_bar(aes(x=shuffled_proposer_types, fill=selected), position = "dodge") +
#   xlab("Was candidate index selected as proposer?") +
#   ylab("Number of validators") 

#ggsave("/Users/sandra/data/rig/plots/scenario3_barchart2.png")

# Check to see which validator indices were set to "accept"
# ----------------------------------------------------------
selected_validators_scenario_3 <- proposers_scenario_3_DF_shuffled[which(proposers_scenario_3_DF_shuffled$selected=='yes')]   # 
first_selected_validator_scenario_3 <-selected_validators_scenario_3[1] %>%
  select(validator_idx,proposer_type=shuffled_proposer_types,selected)                  ## validator index = 0, and proposer type = B

# Run simulations to see what happens over time


# Note that in scenario 3, the apart from the change in the probability of a candidate index being selected as a proposer, the probability of being selected if you are a fully consolidated validator is hugely reduced. In this example we have the probability of being the candidate index as 3,360/311,584 = 0.0108 - approx 1.08%
# In summary - I will include a table in the document to show how the dynamics change for this scenario.
# 
```


## Draw a plot of EB (horizontal axis) vs the probability of passing the test (vertical axis). 
```{r}
x <- c(32, 64, 160, 320, 960, 2048)
y <- c(0.015625, 0.03125, 0.078125, 0.15625, 0.46875, 1.00)

proposer_check <- data.frame(x,y)

proposer_check_graph <- ggplot(data=proposer_check, aes(x=x,y=y)) +
                        geom_line() +
                        xlab("validator effective balance") +
                        ylab("probability of passing proposer check") +
                        xlim(32,2048) +
                        ylim(0,1) +
                        geom_segment(aes(x = 32, y = 0, xend = 32, yend = 0.015625, colour="firebrick"))
proposer_check_graph <- proposer_check_graph +
                        geom_segment(aes(x = 64, y = 0, xend = 64, yend = 0.03125, colour="turquoise")) 
proposer_check_graph <- proposer_check_graph +
                        geom_segment(aes(x = 160, y = 0, xend = 160, yend = 0.078125, colour="gold"))
proposer_check_graph <- proposer_check_graph +
                        geom_segment(aes(x = 320, y = 0, xend = 320, yend = 0.15625, colour="grey")) 
proposer_check_graph <- proposer_check_graph +
                        geom_segment(aes(x = 960, y = 0, xend = 960, yend = 0.46875, colour="green4"))
proposer_check_graph <- proposer_check_graph +
                        geom_segment(aes(x = 2048, y = 0, xend = 2048, yend = 1, colour="pink")) 
proposer_check_graph <- proposer_check_graph +
                        labs(colour="Validator\nConsolidation") +
                        scale_colour_manual(labels = c("32 ETH", "64 ETH", "160 ETH", "320 ETH", "960 ETH", "2,048 ETH"), 
                                          values = c("firebrick", "turquoise", "gold", "grey", "green4", "pink"))

# The order of the segments appear incorrectly!! Not sure why??? 

# ANSWER!!! used aes, e.g. geom_segment(aes(x = 2048, y = 0, xend = 2048, yend = 1, colour="pink")) & aes does lazy evaluation - changed code & thought it was working as desired, but then there was no legend :(

ggsave("/Users/sandra/data/rig/plots/proposer_check_graph.png")
```
## Blog post: Negative binomial of proposer eligibility check
Model the number of failures (i.e. not passing the proposer check) before a validator passes the check to become the next proposer
```{r}
n = 716800       # number of draws 
size = 1         # number of successes
prob = 0.015625  # probability of success
negative_bin <- rnbinom(n, size, prob)

median_failures <- median(negative_bin)

# probability of fewer than 100 failures
pnbinom(c(100), size, prob, lower.tail = TRUE, log.p = FALSE)

# probability of more than 100 failures
pnbinom(c(100,200,300,400), size, prob, lower.tail = FALSE, log.p = FALSE)

hist(negative_bin,                                         
     breaks = 500,
     main = "",
     xlab='Number of proposer check failures',
     xlim=c(0,500),
     ylim = c(0,35000))


```
## Blog post: Uniform distribution for generation of random bytes - U(0,255)
Generate a histogram of the number of times different integer values were assigned to validators

```{r}
## ========================================================================================
## Looks good!! Superimpose a uniform distribution to replicate the one in the blog post!!
## ========================================================================================
set.seed(1)

random_integers <- floor(runif(716800, 0, 255))

validator_set <- seq(1,716800)

hist(random_integers,                                         
     breaks = 500,
     main = "",
     xlab='random_byte values generated from U(0,255)',
     ylab='number of validators') 


```

## Example code from R Coder

<https://r-coder.com/uniform-distribution-r/>

```{r cache=TRUE}
# Three columns
par(mfrow = c(1, 3))

x <- seq(-0.5, 1.5, 0.01)

set.seed(1)

# n = 100000
hist(runif(100000), main = "n = 100,000", xlim = c(-0.2, 1.25),
     xlab = "", prob = TRUE)
lines(x, dunif(x), col = "red", lwd = 2)

# Back to the original graphics device
par(mfrow = c(1, 1))
```

The preview shows you a rendered HTML copy of the contents of the
editor. Consequently, unlike *Knit*, *Preview* does not run any R code
chunks. Instead, the output of the chunk when it was last run in the
editor is displayed.
